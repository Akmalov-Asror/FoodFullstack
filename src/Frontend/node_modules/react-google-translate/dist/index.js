var react = require('react');

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var Translate = require('@google-cloud/translate').v2.Translate;

var translate;
var setConfig = function setConfig(_ref) {
  var clientEmail = _ref.clientEmail,
      privateKey = _ref.privateKey,
      projectId = _ref.projectId;

  try {
    translate = new Translate({
      credentials: {
        private_key: privateKey,
        client_email: clientEmail
      },
      projectId: projectId
    });
    return Promise.resolve();
  } catch (e) {
    return Promise.reject(e);
  }
};
var getLanguages = function getLanguages() {
  try {
    return Promise.resolve(_catch(function () {
      return Promise.resolve(translate.getLanguages()).then(function (_ref2) {
        var list = _ref2[0];
        var options = list.map(function (item) {
          return {
            label: item.name,
            value: item.code
          };
        });
        return options;
      });
    }, function (error) {
      console.error('Error at detectLanguage --> ', "" + error);
      return 0;
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
var translateText = function translateText(text, targetLanguage) {
  try {
    return Promise.resolve(_catch(function () {
      return Promise.resolve(translate.translate(text, targetLanguage)).then(function (_ref3) {
        var response = _ref3[0];
        var result = response;

        if (Array.isArray(response)) {
          result = response.map(function (val, index) {
            return val !== '' ? val : text[index];
          });
        }

        return result;
      });
    }, function (error) {
      console.error('1 => Error at translatedText --> ', "" + error);
      return '';
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var useLazyTranslate = function useLazyTranslate(props) {
  var language = props.language,
      skip = props.skip;

  var _useState = react.useState(true),
      loading = _useState[0],
      setLoading = _useState[1];

  var _useState2 = react.useState(false),
      called = _useState2[0],
      setCalled = _useState2[1];

  var _useState3 = react.useState([]),
      data = _useState3[0],
      setData = _useState3[1];

  react.useEffect(function () {
    if (skip) {
      setCalled(true);
      setLoading(false);
    }
  }, []);
  return [react.useCallback(function (text, target) {
    if (skip) {
      return null;
    }

    return translateText(text, target || language).then(function (res) {
      setData(res);
    })["finally"](function () {
      setCalled(true);
      setLoading(false);
    });
  }, [language]), {
    called: called,
    loading: loading,
    data: data
  }];
};
var useTranslate = function useTranslate(text, props) {
  var _useLazyTranslate = useLazyTranslate(props),
      translate = _useLazyTranslate[0],
      _useLazyTranslate$ = _useLazyTranslate[1],
      loading = _useLazyTranslate$.loading,
      data = _useLazyTranslate$.data;

  react.useEffect(function () {
    var mounted = true;

    if (mounted) {
      translate(text);
    }

    return function () {
      mounted = false;
    };
  }, []);
  return {
    loading: loading,
    data: data
  };
};

exports.getLanguages = getLanguages;
exports.setConfig = setConfig;
exports.useLazyTranslate = useLazyTranslate;
exports.useTranslate = useTranslate;
//# sourceMappingURL=index.js.map
