{"ast":null,"code":"\"use strict\";\n\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\nvar base64 = exports;\n\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\nbase64.length = function length(string) {\n  var p = string.length;\n  if (!p) return 0;\n  var n = 0;\n  while (--p % 4 > 1 && string.charAt(p) === \"=\") ++n;\n  return Math.ceil(string.length * 3) / 4 - n;\n};\n\n// Base64 encoding table\nvar b64 = new Array(64);\n\n// Base64 decoding table\nvar s64 = new Array(123);\n\n// 65..90, 97..122, 48..57, 43, 47\nfor (var i = 0; i < 64;) s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\nbase64.encode = function encode(buffer, start, end) {\n  var parts = null,\n    chunk = [];\n  var i = 0,\n    // output index\n    j = 0,\n    // goto index\n    t; // temporary\n  while (start < end) {\n    var b = buffer[start++];\n    switch (j) {\n      case 0:\n        chunk[i++] = b64[b >> 2];\n        t = (b & 3) << 4;\n        j = 1;\n        break;\n      case 1:\n        chunk[i++] = b64[t | b >> 4];\n        t = (b & 15) << 2;\n        j = 2;\n        break;\n      case 2:\n        chunk[i++] = b64[t | b >> 6];\n        chunk[i++] = b64[b & 63];\n        j = 0;\n        break;\n    }\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n      i = 0;\n    }\n  }\n  if (j) {\n    chunk[i++] = b64[t];\n    chunk[i++] = 61;\n    if (j === 1) chunk[i++] = 61;\n  }\n  if (parts) {\n    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n  return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\nvar invalidEncoding = \"invalid encoding\";\n\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\nbase64.decode = function decode(string, buffer, offset) {\n  var start = offset;\n  var j = 0,\n    // goto index\n    t; // temporary\n  for (var i = 0; i < string.length;) {\n    var c = string.charCodeAt(i++);\n    if (c === 61 && j > 1) break;\n    if ((c = s64[c]) === undefined) throw Error(invalidEncoding);\n    switch (j) {\n      case 0:\n        t = c;\n        j = 1;\n        break;\n      case 1:\n        buffer[offset++] = t << 2 | (c & 48) >> 4;\n        t = c;\n        j = 2;\n        break;\n      case 2:\n        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n        t = c;\n        j = 3;\n        break;\n      case 3:\n        buffer[offset++] = (t & 3) << 6 | c;\n        j = 0;\n        break;\n    }\n  }\n  if (j === 1) throw Error(invalidEncoding);\n  return offset - start;\n};\n\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\nbase64.test = function test(string) {\n  return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n};","map":{"version":3,"names":["base64","exports","length","string","p","n","charAt","Math","ceil","b64","Array","s64","i","encode","buffer","start","end","parts","chunk","j","t","b","push","String","fromCharCode","apply","slice","join","invalidEncoding","decode","offset","c","charCodeAt","undefined","Error","test"],"sources":["C:/Users/ergas/OneDrive/Рабочий стол/inno/FoodFullstack/src/Frontend/node_modules/@protobufjs/base64/index.js"],"sourcesContent":["\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}