{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateServiceStub = void 0;\n/* global window */\n/* global AbortController */\nconst node_fetch_1 = require(\"node-fetch\");\nconst abort_controller_1 = require(\"abort-controller\");\nconst featureDetection_1 = require(\"./featureDetection\");\nconst streamArrayParser_1 = require(\"./streamArrayParser\");\nconst stream_1 = require(\"stream\");\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder) {\n  const fetch = featureDetection_1.hasWindowFetch() ? window.fetch : node_fetch_1.default;\n  const serviceStub = {\n    // close method should close all cancel controllers. If this feature request in the future, we can have a cancelControllerFactory that tracks created cancel controllers, and abort them all in close method.\n    close: () => {\n      return {\n        cancel: () => {}\n      };\n    }\n  };\n  for (const [rpcName, rpc] of Object.entries(rpcs)) {\n    serviceStub[rpcName] = (request, options, _metadata, callback) => {\n      // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n      // Using plain old promises instead.\n      const cancelController = featureDetection_1.hasAbortController() ? new AbortController() : new abort_controller_1.AbortController();\n      const cancelSignal = cancelController.signal;\n      let cancelRequested = false;\n      const fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request);\n      const url = fetchParameters.url;\n      const headers = fetchParameters.headers;\n      for (const key of Object.keys(options)) {\n        headers[key] = options[key][0];\n      }\n      const streamArrayParser = new streamArrayParser_1.StreamArrayParser(rpc);\n      authClient.getRequestHeaders().then(authHeader => {\n        const fetchRequest = {\n          headers: {\n            ...authHeader,\n            ...headers\n          },\n          body: fetchParameters.body,\n          method: fetchParameters.method,\n          signal: cancelSignal\n        };\n        if (fetchParameters.method === 'get' || fetchParameters.method === 'delete') {\n          delete fetchRequest['body'];\n        }\n        return fetch(url, fetchRequest);\n      }).then(response => {\n        if (response.ok && rpc.responseStream) {\n          stream_1.pipeline(response.body, streamArrayParser, err => {\n            if (err && (!cancelRequested || err instanceof Error && err.name !== 'AbortError')) {\n              if (callback) {\n                callback(err);\n              }\n              streamArrayParser.emit('error', err);\n            }\n          });\n          return;\n        } else {\n          return Promise.all([Promise.resolve(response.ok), response.arrayBuffer()]).then(([ok, buffer]) => {\n            const response = responseDecoder(rpc, ok, buffer);\n            callback(null, response);\n          }).catch(err => {\n            if (!cancelRequested || err.name !== 'AbortError') {\n              if (rpc.responseStream) {\n                if (callback) {\n                  callback(err);\n                }\n                streamArrayParser.emit('error', err);\n              } else {\n                callback(err);\n              }\n            }\n          });\n        }\n      });\n      if (rpc.responseStream) {\n        return streamArrayParser;\n      }\n      return {\n        cancel: () => {\n          cancelRequested = true;\n          cancelController.abort();\n        }\n      };\n    };\n  }\n  return serviceStub;\n}\nexports.generateServiceStub = generateServiceStub;","map":{"version":3,"names":["node_fetch_1","require","abort_controller_1","featureDetection_1","streamArrayParser_1","stream_1","generateServiceStub","rpcs","protocol","servicePath","servicePort","authClient","requestEncoder","responseDecoder","fetch","hasWindowFetch","window","default","serviceStub","close","cancel","rpcName","rpc","Object","entries","request","options","_metadata","callback","cancelController","hasAbortController","AbortController","cancelSignal","signal","cancelRequested","fetchParameters","url","headers","key","keys","streamArrayParser","StreamArrayParser","getRequestHeaders","then","authHeader","fetchRequest","body","method","response","ok","responseStream","pipeline","err","Error","name","emit","Promise","all","resolve","arrayBuffer","buffer","catch","abort","exports"],"sources":["../../src/fallbackServiceStub.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}