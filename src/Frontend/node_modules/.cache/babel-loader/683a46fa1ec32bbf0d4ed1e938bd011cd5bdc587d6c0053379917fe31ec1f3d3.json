{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Writer;\nvar util = require(\"./util/minimal\");\nvar BufferWriter; // cyclic\n\nvar LongBits = util.LongBits,\n  base64 = util.base64,\n  utf8 = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n  /**\n   * Function to call.\n   * @type {function(Uint8Array, number, *)}\n   */\n  this.fn = fn;\n\n  /**\n   * Value byte length.\n   * @type {number}\n   */\n  this.len = len;\n\n  /**\n   * Next operation.\n   * @type {Writer.Op|undefined}\n   */\n  this.next = undefined;\n\n  /**\n   * Value to write.\n   * @type {*}\n   */\n  this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n  /**\n   * Current head.\n   * @type {Writer.Op}\n   */\n  this.head = writer.head;\n\n  /**\n   * Current tail.\n   * @type {Writer.Op}\n   */\n  this.tail = writer.tail;\n\n  /**\n   * Current buffer length.\n   * @type {number}\n   */\n  this.len = writer.len;\n\n  /**\n   * Next state.\n   * @type {State|null}\n   */\n  this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n  /**\n   * Current length.\n   * @type {number}\n   */\n  this.len = 0;\n\n  /**\n   * Operations head.\n   * @type {Object}\n   */\n  this.head = new Op(noop, 0, 0);\n\n  /**\n   * Operations tail\n   * @type {Object}\n   */\n  this.tail = this.head;\n\n  /**\n   * Linked forked states.\n   * @type {Object|null}\n   */\n  this.states = null;\n\n  // When a value is written, the writer calculates its byte length and puts it into a linked\n  // list of operations to perform when finish() is called. This both allows us to allocate\n  // buffers of the exact required size and reduces the amount of work we have to do compared\n  // to first calculating over objects and then encoding over objects. In our case, the encoding\n  // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n  return util.Buffer ? function create_buffer_setup() {\n    return (Writer.create = function create_buffer() {\n      return new BufferWriter();\n    })();\n  }\n  /* istanbul ignore next */ : function create_array() {\n    return new Writer();\n  };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n  return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n  this.tail = this.tail.next = new Op(fn, len, val);\n  this.len += len;\n  return this;\n};\nfunction writeByte(val, buf, pos) {\n  buf[pos] = val & 255;\n}\nfunction writeVarint32(val, buf, pos) {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128;\n    val >>>= 7;\n  }\n  buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n  this.len = len;\n  this.next = undefined;\n  this.val = val;\n}\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n  // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n  // uint32 is by far the most frequently used operation and benefits significantly from this.\n  this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n  return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n  return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n  : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n  return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\nfunction writeVarint64(val, buf, pos) {\n  while (val.hi) {\n    buf[pos++] = val.lo & 127 | 128;\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n    val.hi >>>= 7;\n  }\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128;\n    val.lo = val.lo >>> 7;\n  }\n  buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n  var bits = LongBits.from(value);\n  return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n  var bits = LongBits.from(value).zzEncode();\n  return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n  return this._push(writeByte, 1, value ? 1 : 0);\n};\nfunction writeFixed32(val, buf, pos) {\n  buf[pos] = val & 255;\n  buf[pos + 1] = val >>> 8 & 255;\n  buf[pos + 2] = val >>> 16 & 255;\n  buf[pos + 3] = val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n  return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n  var bits = LongBits.from(value);\n  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n  return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n  return this._push(util.float.writeDoubleLE, 8, value);\n};\nvar writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n  buf.set(val, pos); // also works for plain array values\n}\n/* istanbul ignore next */ : function writeBytes_for(val, buf, pos) {\n  for (var i = 0; i < val.length; ++i) buf[pos + i] = val[i];\n};\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n  var len = value.length >>> 0;\n  if (!len) return this._push(writeByte, 1, 0);\n  if (util.isString(value)) {\n    var buf = Writer.alloc(len = base64.length(value));\n    base64.decode(value, buf, 0);\n    value = buf;\n  }\n  return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n  var len = utf8.length(value);\n  return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n  this.states = new State(this);\n  this.head = this.tail = new Op(noop, 0, 0);\n  this.len = 0;\n  return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n  if (this.states) {\n    this.head = this.states.head;\n    this.tail = this.states.tail;\n    this.len = this.states.len;\n    this.states = this.states.next;\n  } else {\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n  }\n  return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n  var head = this.head,\n    tail = this.tail,\n    len = this.len;\n  this.reset().uint32(len);\n  if (len) {\n    this.tail.next = head.next; // skip noop\n    this.tail = tail;\n    this.len += len;\n  }\n  return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n  var head = this.head.next,\n    // skip noop\n    buf = this.constructor.alloc(this.len),\n    pos = 0;\n  while (head) {\n    head.fn(head.val, buf, pos);\n    pos += head.len;\n    head = head.next;\n  }\n  // this.head = this.tail = null;\n  return buf;\n};\nWriter._configure = function (BufferWriter_) {\n  BufferWriter = BufferWriter_;\n  Writer.create = create();\n  BufferWriter._configure();\n};","map":{"version":3,"names":["module","exports","Writer","util","require","BufferWriter","LongBits","base64","utf8","Op","fn","len","val","next","undefined","noop","State","writer","head","tail","states","create","Buffer","create_buffer_setup","create_buffer","create_array","alloc","size","Array","pool","prototype","subarray","_push","push","writeByte","buf","pos","writeVarint32","VarintOp","Object","uint32","write_uint32","value","int32","write_int32","writeVarint64","fromNumber","sint32","write_sint32","hi","lo","uint64","write_uint64","bits","from","length","int64","sint64","write_sint64","zzEncode","bool","write_bool","writeFixed32","fixed32","write_fixed32","sfixed32","fixed64","write_fixed64","sfixed64","float","write_float","writeFloatLE","double","write_double","writeDoubleLE","writeBytes","set","writeBytes_set","writeBytes_for","i","bytes","write_bytes","isString","decode","string","write_string","write","fork","reset","ldelim","finish","constructor","_configure","BufferWriter_"],"sources":["C:/Users/ergas/OneDrive/Рабочий стол/inno/FoodFullstack/src/Frontend/node_modules/protobufjs/src/writer.js"],"sourcesContent":["\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,OAAO,GAAGC,MAAM;AAEvB,IAAIC,IAAI,GAAQC,OAAO,CAAC,gBAAgB,CAAC;AAEzC,IAAIC,YAAY,CAAC,CAAC;;AAElB,IAAIC,QAAQ,GAAIH,IAAI,CAACG,QAAQ;EACzBC,MAAM,GAAMJ,IAAI,CAACI,MAAM;EACvBC,IAAI,GAAQL,IAAI,CAACK,IAAI;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,EAAEA,CAACC,EAAE,EAAEC,GAAG,EAAEC,GAAG,EAAE;EAEtB;AACJ;AACA;AACA;EACI,IAAI,CAACF,EAAE,GAAGA,EAAE;;EAEZ;AACJ;AACA;AACA;EACI,IAAI,CAACC,GAAG,GAAGA,GAAG;;EAEd;AACJ;AACA;AACA;EACI,IAAI,CAACE,IAAI,GAAGC,SAAS;;EAErB;AACJ;AACA;AACA;EACI,IAAI,CAACF,GAAG,GAAGA,GAAG,CAAC,CAAC;AACpB;;AAEA;AACA,SAASG,IAAIA,CAAA,EAAG,CAAC,CAAC,CAAC;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,KAAKA,CAACC,MAAM,EAAE;EAEnB;AACJ;AACA;AACA;EACI,IAAI,CAACC,IAAI,GAAGD,MAAM,CAACC,IAAI;;EAEvB;AACJ;AACA;AACA;EACI,IAAI,CAACC,IAAI,GAAGF,MAAM,CAACE,IAAI;;EAEvB;AACJ;AACA;AACA;EACI,IAAI,CAACR,GAAG,GAAGM,MAAM,CAACN,GAAG;;EAErB;AACJ;AACA;AACA;EACI,IAAI,CAACE,IAAI,GAAGI,MAAM,CAACG,MAAM;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASlB,MAAMA,CAAA,EAAG;EAEd;AACJ;AACA;AACA;EACI,IAAI,CAACS,GAAG,GAAG,CAAC;;EAEZ;AACJ;AACA;AACA;EACI,IAAI,CAACO,IAAI,GAAG,IAAIT,EAAE,CAACM,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;;EAE9B;AACJ;AACA;AACA;EACI,IAAI,CAACI,IAAI,GAAG,IAAI,CAACD,IAAI;;EAErB;AACJ;AACA;AACA;EACI,IAAI,CAACE,MAAM,GAAG,IAAI;;EAElB;EACA;EACA;EACA;EACA;AACJ;;AAEA,IAAIC,MAAM,GAAG,SAASA,MAAMA,CAAA,EAAG;EAC3B,OAAOlB,IAAI,CAACmB,MAAM,GACZ,SAASC,mBAAmBA,CAAA,EAAG;IAC7B,OAAO,CAACrB,MAAM,CAACmB,MAAM,GAAG,SAASG,aAAaA,CAAA,EAAG;MAC7C,OAAO,IAAInB,YAAY,CAAC,CAAC;IAC7B,CAAC,EAAE,CAAC;EACR;EACA,6BACE,SAASoB,YAAYA,CAAA,EAAG;IACtB,OAAO,IAAIvB,MAAM,CAAC,CAAC;EACvB,CAAC;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACmB,MAAM,GAAGA,MAAM,CAAC,CAAC;;AAExB;AACA;AACA;AACA;AACA;AACAnB,MAAM,CAACwB,KAAK,GAAG,SAASA,KAAKA,CAACC,IAAI,EAAE;EAChC,OAAO,IAAIxB,IAAI,CAACyB,KAAK,CAACD,IAAI,CAAC;AAC/B,CAAC;;AAED;AACA;AACA,IAAIxB,IAAI,CAACyB,KAAK,KAAKA,KAAK,EACpB1B,MAAM,CAACwB,KAAK,GAAGvB,IAAI,CAAC0B,IAAI,CAAC3B,MAAM,CAACwB,KAAK,EAAEvB,IAAI,CAACyB,KAAK,CAACE,SAAS,CAACC,QAAQ,CAAC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7B,MAAM,CAAC4B,SAAS,CAACE,KAAK,GAAG,SAASC,IAAIA,CAACvB,EAAE,EAAEC,GAAG,EAAEC,GAAG,EAAE;EACjD,IAAI,CAACO,IAAI,GAAG,IAAI,CAACA,IAAI,CAACN,IAAI,GAAG,IAAIJ,EAAE,CAACC,EAAE,EAAEC,GAAG,EAAEC,GAAG,CAAC;EACjD,IAAI,CAACD,GAAG,IAAIA,GAAG;EACf,OAAO,IAAI;AACf,CAAC;AAED,SAASuB,SAASA,CAACtB,GAAG,EAAEuB,GAAG,EAAEC,GAAG,EAAE;EAC9BD,GAAG,CAACC,GAAG,CAAC,GAAGxB,GAAG,GAAG,GAAG;AACxB;AAEA,SAASyB,aAAaA,CAACzB,GAAG,EAAEuB,GAAG,EAAEC,GAAG,EAAE;EAClC,OAAOxB,GAAG,GAAG,GAAG,EAAE;IACduB,GAAG,CAACC,GAAG,EAAE,CAAC,GAAGxB,GAAG,GAAG,GAAG,GAAG,GAAG;IAC5BA,GAAG,MAAM,CAAC;EACd;EACAuB,GAAG,CAACC,GAAG,CAAC,GAAGxB,GAAG;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0B,QAAQA,CAAC3B,GAAG,EAAEC,GAAG,EAAE;EACxB,IAAI,CAACD,GAAG,GAAGA,GAAG;EACd,IAAI,CAACE,IAAI,GAAGC,SAAS;EACrB,IAAI,CAACF,GAAG,GAAGA,GAAG;AAClB;AAEA0B,QAAQ,CAACR,SAAS,GAAGS,MAAM,CAAClB,MAAM,CAACZ,EAAE,CAACqB,SAAS,CAAC;AAChDQ,QAAQ,CAACR,SAAS,CAACpB,EAAE,GAAG2B,aAAa;;AAErC;AACA;AACA;AACA;AACA;AACAnC,MAAM,CAAC4B,SAAS,CAACU,MAAM,GAAG,SAASC,YAAYA,CAACC,KAAK,EAAE;EACnD;EACA;EACA,IAAI,CAAC/B,GAAG,IAAI,CAAC,IAAI,CAACQ,IAAI,GAAG,IAAI,CAACA,IAAI,CAACN,IAAI,GAAG,IAAIyB,QAAQ,CAClD,CAACI,KAAK,GAAGA,KAAK,KAAK,CAAC,IACV,GAAG,GAAS,CAAC,GACrBA,KAAK,GAAG,KAAK,GAAO,CAAC,GACrBA,KAAK,GAAG,OAAO,GAAK,CAAC,GACrBA,KAAK,GAAG,SAAS,GAAG,CAAC,GACD,CAAC,EAC3BA,KAAK,CAAC,EAAE/B,GAAG;EACX,OAAO,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAT,MAAM,CAAC4B,SAAS,CAACa,KAAK,GAAG,SAASC,WAAWA,CAACF,KAAK,EAAE;EACjD,OAAOA,KAAK,GAAG,CAAC,GACV,IAAI,CAACV,KAAK,CAACa,aAAa,EAAE,EAAE,EAAEvC,QAAQ,CAACwC,UAAU,CAACJ,KAAK,CAAC,CAAC,CAAC;EAAA,EAC1D,IAAI,CAACF,MAAM,CAACE,KAAK,CAAC;AAC5B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAxC,MAAM,CAAC4B,SAAS,CAACiB,MAAM,GAAG,SAASC,YAAYA,CAACN,KAAK,EAAE;EACnD,OAAO,IAAI,CAACF,MAAM,CAAC,CAACE,KAAK,IAAI,CAAC,GAAGA,KAAK,IAAI,EAAE,MAAM,CAAC,CAAC;AACxD,CAAC;AAED,SAASG,aAAaA,CAACjC,GAAG,EAAEuB,GAAG,EAAEC,GAAG,EAAE;EAClC,OAAOxB,GAAG,CAACqC,EAAE,EAAE;IACXd,GAAG,CAACC,GAAG,EAAE,CAAC,GAAGxB,GAAG,CAACsC,EAAE,GAAG,GAAG,GAAG,GAAG;IAC/BtC,GAAG,CAACsC,EAAE,GAAG,CAACtC,GAAG,CAACsC,EAAE,KAAK,CAAC,GAAGtC,GAAG,CAACqC,EAAE,IAAI,EAAE,MAAM,CAAC;IAC5CrC,GAAG,CAACqC,EAAE,MAAM,CAAC;EACjB;EACA,OAAOrC,GAAG,CAACsC,EAAE,GAAG,GAAG,EAAE;IACjBf,GAAG,CAACC,GAAG,EAAE,CAAC,GAAGxB,GAAG,CAACsC,EAAE,GAAG,GAAG,GAAG,GAAG;IAC/BtC,GAAG,CAACsC,EAAE,GAAGtC,GAAG,CAACsC,EAAE,KAAK,CAAC;EACzB;EACAf,GAAG,CAACC,GAAG,EAAE,CAAC,GAAGxB,GAAG,CAACsC,EAAE;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAhD,MAAM,CAAC4B,SAAS,CAACqB,MAAM,GAAG,SAASC,YAAYA,CAACV,KAAK,EAAE;EACnD,IAAIW,IAAI,GAAG/C,QAAQ,CAACgD,IAAI,CAACZ,KAAK,CAAC;EAC/B,OAAO,IAAI,CAACV,KAAK,CAACa,aAAa,EAAEQ,IAAI,CAACE,MAAM,CAAC,CAAC,EAAEF,IAAI,CAAC;AACzD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAnD,MAAM,CAAC4B,SAAS,CAAC0B,KAAK,GAAGtD,MAAM,CAAC4B,SAAS,CAACqB,MAAM;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACAjD,MAAM,CAAC4B,SAAS,CAAC2B,MAAM,GAAG,SAASC,YAAYA,CAAChB,KAAK,EAAE;EACnD,IAAIW,IAAI,GAAG/C,QAAQ,CAACgD,IAAI,CAACZ,KAAK,CAAC,CAACiB,QAAQ,CAAC,CAAC;EAC1C,OAAO,IAAI,CAAC3B,KAAK,CAACa,aAAa,EAAEQ,IAAI,CAACE,MAAM,CAAC,CAAC,EAAEF,IAAI,CAAC;AACzD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAnD,MAAM,CAAC4B,SAAS,CAAC8B,IAAI,GAAG,SAASC,UAAUA,CAACnB,KAAK,EAAE;EAC/C,OAAO,IAAI,CAACV,KAAK,CAACE,SAAS,EAAE,CAAC,EAAEQ,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;AAClD,CAAC;AAED,SAASoB,YAAYA,CAAClD,GAAG,EAAEuB,GAAG,EAAEC,GAAG,EAAE;EACjCD,GAAG,CAACC,GAAG,CAAK,GAAIxB,GAAG,GAAW,GAAG;EACjCuB,GAAG,CAACC,GAAG,GAAG,CAAC,CAAC,GAAIxB,GAAG,KAAK,CAAC,GAAK,GAAG;EACjCuB,GAAG,CAACC,GAAG,GAAG,CAAC,CAAC,GAAIxB,GAAG,KAAK,EAAE,GAAI,GAAG;EACjCuB,GAAG,CAACC,GAAG,GAAG,CAAC,CAAC,GAAIxB,GAAG,KAAK,EAAE;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACAV,MAAM,CAAC4B,SAAS,CAACiC,OAAO,GAAG,SAASC,aAAaA,CAACtB,KAAK,EAAE;EACrD,OAAO,IAAI,CAACV,KAAK,CAAC8B,YAAY,EAAE,CAAC,EAAEpB,KAAK,KAAK,CAAC,CAAC;AACnD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAxC,MAAM,CAAC4B,SAAS,CAACmC,QAAQ,GAAG/D,MAAM,CAAC4B,SAAS,CAACiC,OAAO;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA7D,MAAM,CAAC4B,SAAS,CAACoC,OAAO,GAAG,SAASC,aAAaA,CAACzB,KAAK,EAAE;EACrD,IAAIW,IAAI,GAAG/C,QAAQ,CAACgD,IAAI,CAACZ,KAAK,CAAC;EAC/B,OAAO,IAAI,CAACV,KAAK,CAAC8B,YAAY,EAAE,CAAC,EAAET,IAAI,CAACH,EAAE,CAAC,CAAClB,KAAK,CAAC8B,YAAY,EAAE,CAAC,EAAET,IAAI,CAACJ,EAAE,CAAC;AAC/E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA/C,MAAM,CAAC4B,SAAS,CAACsC,QAAQ,GAAGlE,MAAM,CAAC4B,SAAS,CAACoC,OAAO;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACAhE,MAAM,CAAC4B,SAAS,CAACuC,KAAK,GAAG,SAASC,WAAWA,CAAC5B,KAAK,EAAE;EACjD,OAAO,IAAI,CAACV,KAAK,CAAC7B,IAAI,CAACkE,KAAK,CAACE,YAAY,EAAE,CAAC,EAAE7B,KAAK,CAAC;AACxD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAxC,MAAM,CAAC4B,SAAS,CAAC0C,MAAM,GAAG,SAASC,YAAYA,CAAC/B,KAAK,EAAE;EACnD,OAAO,IAAI,CAACV,KAAK,CAAC7B,IAAI,CAACkE,KAAK,CAACK,aAAa,EAAE,CAAC,EAAEhC,KAAK,CAAC;AACzD,CAAC;AAED,IAAIiC,UAAU,GAAGxE,IAAI,CAACyB,KAAK,CAACE,SAAS,CAAC8C,GAAG,GACnC,SAASC,cAAcA,CAACjE,GAAG,EAAEuB,GAAG,EAAEC,GAAG,EAAE;EACrCD,GAAG,CAACyC,GAAG,CAAChE,GAAG,EAAEwB,GAAG,CAAC,CAAC,CAAC;AACvB;AACA,6BACE,SAAS0C,cAAcA,CAAClE,GAAG,EAAEuB,GAAG,EAAEC,GAAG,EAAE;EACrC,KAAK,IAAI2C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnE,GAAG,CAAC2C,MAAM,EAAE,EAAEwB,CAAC,EAC/B5C,GAAG,CAACC,GAAG,GAAG2C,CAAC,CAAC,GAAGnE,GAAG,CAACmE,CAAC,CAAC;AAC7B,CAAC;;AAEL;AACA;AACA;AACA;AACA;AACA7E,MAAM,CAAC4B,SAAS,CAACkD,KAAK,GAAG,SAASC,WAAWA,CAACvC,KAAK,EAAE;EACjD,IAAI/B,GAAG,GAAG+B,KAAK,CAACa,MAAM,KAAK,CAAC;EAC5B,IAAI,CAAC5C,GAAG,EACJ,OAAO,IAAI,CAACqB,KAAK,CAACE,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC;EACtC,IAAI/B,IAAI,CAAC+E,QAAQ,CAACxC,KAAK,CAAC,EAAE;IACtB,IAAIP,GAAG,GAAGjC,MAAM,CAACwB,KAAK,CAACf,GAAG,GAAGJ,MAAM,CAACgD,MAAM,CAACb,KAAK,CAAC,CAAC;IAClDnC,MAAM,CAAC4E,MAAM,CAACzC,KAAK,EAAEP,GAAG,EAAE,CAAC,CAAC;IAC5BO,KAAK,GAAGP,GAAG;EACf;EACA,OAAO,IAAI,CAACK,MAAM,CAAC7B,GAAG,CAAC,CAACqB,KAAK,CAAC2C,UAAU,EAAEhE,GAAG,EAAE+B,KAAK,CAAC;AACzD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAxC,MAAM,CAAC4B,SAAS,CAACsD,MAAM,GAAG,SAASC,YAAYA,CAAC3C,KAAK,EAAE;EACnD,IAAI/B,GAAG,GAAGH,IAAI,CAAC+C,MAAM,CAACb,KAAK,CAAC;EAC5B,OAAO/B,GAAG,GACJ,IAAI,CAAC6B,MAAM,CAAC7B,GAAG,CAAC,CAACqB,KAAK,CAACxB,IAAI,CAAC8E,KAAK,EAAE3E,GAAG,EAAE+B,KAAK,CAAC,GAC9C,IAAI,CAACV,KAAK,CAACE,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC;AACrC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAhC,MAAM,CAAC4B,SAAS,CAACyD,IAAI,GAAG,SAASA,IAAIA,CAAA,EAAG;EACpC,IAAI,CAACnE,MAAM,GAAG,IAAIJ,KAAK,CAAC,IAAI,CAAC;EAC7B,IAAI,CAACE,IAAI,GAAG,IAAI,CAACC,IAAI,GAAG,IAAIV,EAAE,CAACM,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;EAC1C,IAAI,CAACJ,GAAG,GAAG,CAAC;EACZ,OAAO,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACAT,MAAM,CAAC4B,SAAS,CAAC0D,KAAK,GAAG,SAASA,KAAKA,CAAA,EAAG;EACtC,IAAI,IAAI,CAACpE,MAAM,EAAE;IACb,IAAI,CAACF,IAAI,GAAK,IAAI,CAACE,MAAM,CAACF,IAAI;IAC9B,IAAI,CAACC,IAAI,GAAK,IAAI,CAACC,MAAM,CAACD,IAAI;IAC9B,IAAI,CAACR,GAAG,GAAM,IAAI,CAACS,MAAM,CAACT,GAAG;IAC7B,IAAI,CAACS,MAAM,GAAG,IAAI,CAACA,MAAM,CAACP,IAAI;EAClC,CAAC,MAAM;IACH,IAAI,CAACK,IAAI,GAAG,IAAI,CAACC,IAAI,GAAG,IAAIV,EAAE,CAACM,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;IAC1C,IAAI,CAACJ,GAAG,GAAI,CAAC;EACjB;EACA,OAAO,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACAT,MAAM,CAAC4B,SAAS,CAAC2D,MAAM,GAAG,SAASA,MAAMA,CAAA,EAAG;EACxC,IAAIvE,IAAI,GAAG,IAAI,CAACA,IAAI;IAChBC,IAAI,GAAG,IAAI,CAACA,IAAI;IAChBR,GAAG,GAAI,IAAI,CAACA,GAAG;EACnB,IAAI,CAAC6E,KAAK,CAAC,CAAC,CAAChD,MAAM,CAAC7B,GAAG,CAAC;EACxB,IAAIA,GAAG,EAAE;IACL,IAAI,CAACQ,IAAI,CAACN,IAAI,GAAGK,IAAI,CAACL,IAAI,CAAC,CAAC;IAC5B,IAAI,CAACM,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACR,GAAG,IAAIA,GAAG;EACnB;EACA,OAAO,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACAT,MAAM,CAAC4B,SAAS,CAAC4D,MAAM,GAAG,SAASA,MAAMA,CAAA,EAAG;EACxC,IAAIxE,IAAI,GAAG,IAAI,CAACA,IAAI,CAACL,IAAI;IAAE;IACvBsB,GAAG,GAAI,IAAI,CAACwD,WAAW,CAACjE,KAAK,CAAC,IAAI,CAACf,GAAG,CAAC;IACvCyB,GAAG,GAAI,CAAC;EACZ,OAAOlB,IAAI,EAAE;IACTA,IAAI,CAACR,EAAE,CAACQ,IAAI,CAACN,GAAG,EAAEuB,GAAG,EAAEC,GAAG,CAAC;IAC3BA,GAAG,IAAIlB,IAAI,CAACP,GAAG;IACfO,IAAI,GAAGA,IAAI,CAACL,IAAI;EACpB;EACA;EACA,OAAOsB,GAAG;AACd,CAAC;AAEDjC,MAAM,CAAC0F,UAAU,GAAG,UAASC,aAAa,EAAE;EACxCxF,YAAY,GAAGwF,aAAa;EAC5B3F,MAAM,CAACmB,MAAM,GAAGA,MAAM,CAAC,CAAC;EACxBhB,YAAY,CAACuF,UAAU,CAAC,CAAC;AAC7B,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}