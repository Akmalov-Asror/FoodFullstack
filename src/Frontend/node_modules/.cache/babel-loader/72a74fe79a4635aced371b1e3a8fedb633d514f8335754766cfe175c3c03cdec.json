{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PagedApiCaller = void 0;\nconst call_1 = require(\"../call\");\nconst googleError_1 = require(\"../googleError\");\nconst resourceCollector_1 = require(\"./resourceCollector\");\nclass PagedApiCaller {\n  /**\n   * Creates an API caller that returns a stream to performs page-streaming.\n   *\n   * @private\n   * @constructor\n   * @param {PageDescriptor} pageDescriptor - indicates the structure\n   *   of page streaming to be performed.\n   */\n  constructor(pageDescriptor) {\n    this.pageDescriptor = pageDescriptor;\n  }\n  /**\n   * This function translates between regular gRPC calls (that accepts a request and returns a response,\n   * and does not know anything about pages and page tokens) and the users' callback (that expects\n   * to see resources from one page, a request to get the next page, and the raw response from the server).\n   *\n   * It generates a function that can be passed as a callback function to a gRPC call, will understand\n   * pagination-specific fields in the response, and call the users' callback after having those fields\n   * parsed.\n   *\n   * @param request Request object. It needs to be passed to all subsequent next page requests\n   * (the main content of the request object stays unchanged, only the next page token changes)\n   * @param callback The user's callback that expects the page content, next page request, and raw response.\n   */\n  generateParseResponseCallback(request, callback) {\n    const resourceFieldName = this.pageDescriptor.resourceField;\n    const responsePageTokenFieldName = this.pageDescriptor.responsePageTokenField;\n    const requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n    return (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      if (!request) {\n        callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n        return;\n      }\n      if (!response) {\n        callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n        return;\n      }\n      const resources = response[resourceFieldName] || [];\n      const pageToken = response[responsePageTokenFieldName];\n      let nextPageRequest = null;\n      if (pageToken) {\n        nextPageRequest = Object.assign({}, request);\n        nextPageRequest[requestPageTokenFieldName] = pageToken;\n      }\n      callback(err, resources, nextPageRequest, response);\n    };\n  }\n  /**\n   * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\n   * The original gRPC call just calls callback(err, result).\n   * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\n   *\n   * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\n   * request, metadata, call options, and callback.\n   */\n  wrap(func) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return function wrappedCall(argument, metadata, options, callback) {\n      return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n    };\n  }\n  /**\n   * Makes it possible to use both callback-based and promise-based calls.\n   * Returns an OngoingCall or OngoingCallPromise object.\n   * Regardless of which one is returned, it always has a `.callback` to call.\n   *\n   * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\n   * @param [callback] Callback to be called, if any.\n   */\n  init(callback) {\n    if (callback) {\n      return new call_1.OngoingCall(callback);\n    }\n    return new call_1.OngoingCallPromise();\n  }\n  /**\n   * Implements auto-pagination logic.\n   *\n   * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\n   * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\n   * accept just two parameters: (request, callback).\n   * @param request A request object that came from the user.\n   * @param settings Call settings. We are interested in `maxResults`, autoPaginate`, `pageToken`, and `pageSize`\n   * (they are all optional).\n   * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\n   * and is used to return results to the user.\n   */\n  call(apiCall, request, settings, ongoingCall) {\n    request = Object.assign({}, request);\n    // If settings object contain pageToken or pageSize, override the corresponding fields in the request object.\n    if (settings.pageToken) {\n      request[this.pageDescriptor.requestPageTokenField] = settings.pageToken;\n    }\n    if (settings.pageSize) {\n      request[this.pageDescriptor.requestPageSizeField] = settings.pageSize;\n    }\n    if (!settings.autoPaginate) {\n      // they don't want auto-pagination this time - okay, just call once\n      ongoingCall.call(apiCall, request);\n      return;\n    }\n    const maxResults = settings.maxResults || -1;\n    const resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n    resourceCollector.processAllPages(request).then(resources => ongoingCall.callback(null, resources), err => ongoingCall.callback(err));\n  }\n  fail(ongoingCall, err) {\n    ongoingCall.callback(err);\n  }\n  result(ongoingCall) {\n    return ongoingCall.promise;\n  }\n}\nexports.PagedApiCaller = PagedApiCaller;","map":{"version":3,"names":["call_1","require","googleError_1","resourceCollector_1","PagedApiCaller","constructor","pageDescriptor","generateParseResponseCallback","request","callback","resourceFieldName","resourceField","responsePageTokenFieldName","responsePageTokenField","requestPageTokenFieldName","requestPageTokenField","err","response","GoogleError","resources","pageToken","nextPageRequest","Object","assign","wrap","func","self","wrappedCall","argument","metadata","options","init","OngoingCall","OngoingCallPromise","call","apiCall","settings","ongoingCall","pageSize","requestPageSizeField","autoPaginate","maxResults","resourceCollector","ResourceCollector","processAllPages","then","fail","result","promise","exports"],"sources":["../../../src/paginationCalls/pagedApiCaller.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}