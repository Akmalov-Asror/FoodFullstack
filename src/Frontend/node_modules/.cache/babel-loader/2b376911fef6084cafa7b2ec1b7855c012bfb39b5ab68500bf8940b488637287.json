{"ast":null,"code":"\"use strict\";\n\nmodule.exports = MapField;\n\n// extends Field\nvar Field = require(\"./field\");\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\nvar types = require(\"./types\"),\n  util = require(\"./util\");\n\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction MapField(name, id, keyType, type, options, comment) {\n  Field.call(this, name, id, type, undefined, undefined, options, comment);\n\n  /* istanbul ignore if */\n  if (!util.isString(keyType)) throw TypeError(\"keyType must be a string\");\n\n  /**\n   * Key type.\n   * @type {string}\n   */\n  this.keyType = keyType; // toJSON, marker\n\n  /**\n   * Resolved key type if not a basic type.\n   * @type {ReflectionObject|null}\n   */\n  this.resolvedKeyType = null;\n\n  // Overrides Field#map\n  this.map = true;\n}\n\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */\n\n/**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */\n\n/**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */\nMapField.fromJSON = function fromJSON(name, json) {\n  return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\n  var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n  return util.toObject([\"keyType\", this.keyType, \"type\", this.type, \"id\", this.id, \"extend\", this.extend, \"options\", this.options, \"comment\", keepComments ? this.comment : undefined]);\n};\n\n/**\n * @override\n */\nMapField.prototype.resolve = function resolve() {\n  if (this.resolved) return this;\n\n  // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n  if (types.mapKey[this.keyType] === undefined) throw Error(\"invalid key type: \" + this.keyType);\n  return Field.prototype.resolve.call(this);\n};\n\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n  // submessage value: decorate the submessage and use its name as the type\n  if (typeof fieldValueType === \"function\") fieldValueType = util.decorateType(fieldValueType).name;\n\n  // enum reference value: create a reflected copy of the enum and keep reuseing it\n  else if (fieldValueType && typeof fieldValueType === \"object\") fieldValueType = util.decorateEnum(fieldValueType).name;\n  return function mapFieldDecorator(prototype, fieldName) {\n    util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n  };\n};","map":{"version":3,"names":["module","exports","MapField","Field","require","prototype","Object","create","constructor","className","types","util","name","id","keyType","type","options","comment","call","undefined","isString","TypeError","resolvedKeyType","map","fromJSON","json","toJSON","toJSONOptions","keepComments","Boolean","toObject","extend","resolve","resolved","mapKey","Error","d","decorateMapField","fieldId","fieldKeyType","fieldValueType","decorateType","decorateEnum","mapFieldDecorator","fieldName","add"],"sources":["C:/Users/ergas/OneDrive/Рабочий стол/inno/FoodFullstack/src/Frontend/node_modules/google-gax/node_modules/protobufjs/src/mapfield.js"],"sourcesContent":["\"use strict\";\nmodule.exports = MapField;\n\n// extends Field\nvar Field = require(\"./field\");\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\n\nvar types   = require(\"./types\"),\n    util    = require(\"./util\");\n\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction MapField(name, id, keyType, type, options, comment) {\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\n\n    /* istanbul ignore if */\n    if (!util.isString(keyType))\n        throw TypeError(\"keyType must be a string\");\n\n    /**\n     * Key type.\n     * @type {string}\n     */\n    this.keyType = keyType; // toJSON, marker\n\n    /**\n     * Resolved key type if not a basic type.\n     * @type {ReflectionObject|null}\n     */\n    this.resolvedKeyType = null;\n\n    // Overrides Field#map\n    this.map = true;\n}\n\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */\n\n/**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */\n\n/**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */\nMapField.fromJSON = function fromJSON(name, json) {\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"keyType\" , this.keyType,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nMapField.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n    if (types.mapKey[this.keyType] === undefined)\n        throw Error(\"invalid key type: \" + this.keyType);\n\n    return Field.prototype.resolve.call(this);\n};\n\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n\n    // submessage value: decorate the submessage and use its name as the type\n    if (typeof fieldValueType === \"function\")\n        fieldValueType = util.decorateType(fieldValueType).name;\n\n    // enum reference value: create a reflected copy of the enum and keep reuseing it\n    else if (fieldValueType && typeof fieldValueType === \"object\")\n        fieldValueType = util.decorateEnum(fieldValueType).name;\n\n    return function mapFieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}